// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /home/qxj/Workload-Aware-Co-Optimization/code_generator/taco/build/bin/taco "C(i,j)=A(i,k)*B(k,j)" -f=C:dd:0,1 -f=A:dd:0,1 -f=B:ds:0,1 -t=C:float -t=A:float -t=B:float -write-compute=taco_kernel.c -s="bound(i,ib,32, MaxExact)" -s="bound(k,kb,256, MaxExact)" -s="parallelize(kb, CPUVector, Atomics)"

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *Cd, taco_tensor_t *Ad, taco_tensor_t *Bd) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  float* __restrict C_vals = (float*)(C->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int A2_dimension = (int)(A->dimensions[1]);
  float* __restrict A_vals = (float*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int* __restrict B2_pos = (int*)(B->indices[1][0]);
  int* __restrict B2_crd = (int*)(B->indices[1][1]);
  float* __restrict B_vals = (float*)(B->vals);

  for (int32_t ib = 0; ib < 32; ib++) {
    #pragma vector 
    for (int32_t kb = 0; kb < 256; kb++) {
      int32_t kA = ib * A2_dimension + kb;
      for (int32_t jB = B2_pos[kb]; jB < B2_pos[(kb + 1)]; jB++) {
        int32_t j = B2_crd[jB];
        int32_t jC = ib * C2_dimension + j;
        #pragma omp atomic
        C_vals[jC] = C_vals[jC] + A_vals[kA] * B_vals[jB];
      }
    }
  }
  return 0;
}
