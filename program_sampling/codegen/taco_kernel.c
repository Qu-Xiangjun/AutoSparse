#include <stdint.h> 
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;
  int32_t*     dimensions;
  int32_t      csize;
  int32_t*     mode_ordering;
  taco_mode_t* mode_types;
  uint8_t***   indices;
  uint8_t*     vals;
  int32_t      vals_size;
} taco_tensor_t;
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /home/qxj/AutoSparse/taco/build/bin/taco "C(i,j)=A(i,k)*B(k,j)" -f=C:dd:0,1 -f=A:ds:0,1 -f=B:dd:0,1 -t=C:float -t=A:float -t=B:float -s="bound(i,iBound,32,MaxExact)" -s="bound(j,jBound,256,MaxExact)" -s="parallelize(iBound,CPUThread,NoRaces)" -write-compute=taco_kernel.c

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *Cd, taco_tensor_t *Ad, taco_tensor_t *Bd) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  float* __restrict C_vals = (float*)(C->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int* __restrict A2_pos = (int*)(A->indices[1][0]);
  int* __restrict A2_crd = (int*)(A->indices[1][1]);
  float* __restrict A_vals = (float*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  float* __restrict B_vals = (float*)(B->vals);

  #pragma omp parallel for schedule(runtime)
  for (int32_t iBound = 0; iBound < 32; iBound++) {
    for (int32_t kA = A2_pos[iBound]; kA < A2_pos[(iBound + 1)]; kA++) {
      int32_t k = A2_crd[kA];
      for (int32_t jBound = 0; jBound < 256; jBound++) {
        int32_t jB = k * B2_dimension + jBound;
        int32_t jC = iBound * C2_dimension + jBound;
        C_vals[jC] = C_vals[jC] + A_vals[kA] * B_vals[jB];
      }
    }
  }
  return 0;
}
